require_relative '../socket'

module EZMQ
  # A {ROUTER} is an intermediary socket used for forwarding messages in
  # advanced network configurations. It is capable of both receiving and
  # sending messages, but adds the following behavior:
  #
  # * When **receiving** a message, it adds a part to the beginning of the
  #   message with a string uniquely identifying the socket it received the
  #   message from. This string is the other socket's {#identity} attribute
  #   if set; if not, it is randomly generated by the {ROUTER}.
  # * When **sending** a message, it removes the first part of the message
  #   and reads it to determine the identity of the socket to send to.
  #   This message part *must* match the identifying string of a socket
  #   known to the {ROUTER}. The identified socket will receive the message.
  #   If the identifier is unknown or the socket is no longer connected, the
  #   error handling behavior depends on the value of the {#fail_on_unreachable}
  #   attribute.
  #
  # The primary use case for this socket is to allow request messages from
  # a requester (probably a {REQ} socket) to be conveyed across intermediate
  # hops before reaching a final responder (probably a {REP} socket). It
  # is often paired with a {DEALER} socket to form a simple forwarding
  # proxy.
  #
  # In basic bridging scenarios like the above, address parts are added
  # and removed automatically and no special handling is needed. If you
  # intend to inspect or modify the messages from a {ROUTER} socket in any
  # way, however, or use it as a final responder, it is vital to be aware
  # of the message's address parts and treat them separately from its
  # business data.  (Originating {REQ} sockets simplify this somewhat by
  # including an empty message part as a delimiter before the user data.)
  class ROUTER < Socket
    include Receivable
    include Sendable

    # @!attribute [rw] fail_on_unreachable
    #   Represents the strangely named and strangely write-only 0mq
    #   `ROUTER_MANDATORY` option. If set to 1 or *true*, messages with
    #   an identifier that is unknown to the socket or identifying a
    #   peer that is no longer connected will raise an {EHOSTUNREACHABLE}
    #   exception.  Defaults to 0 (false), meaning messages that cannot
    #   be routed will be silently dropped.
    def fail_on_unreachable=(val)
      self.router_mandatory = val
      @fail_on_unreachable = case val
        when false then 0
        when true then 1
        else val
      end
    end

    def fail_on_unreachable
      @fail_on_unreachable ||= 0
    end

    def fail_on_unreachable?
      fail_on_unreachable == 1
    end

  protected
    set_option :router_mandatory
  end
end
